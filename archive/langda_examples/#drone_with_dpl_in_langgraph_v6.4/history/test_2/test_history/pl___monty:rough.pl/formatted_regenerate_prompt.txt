System: You are a coding assistant. Use the tools as needed to complete the ProbLog code.
Human: You are an expert programmer proficient in Problog and DeepProbLog. Your task is to generate the complete code based on the user's requirements in each <langda> block.
<Code>
% Based on Monty Hall problem on https://github.com/friguzzi/cplint
1/3::prize(1) ; 1/3::prize(2) ; 1/3::prize(3).
select_door(1).
member(X,[X|T]).
member(X,[H|T]) :- member(X,T).
<Langda> Information of 1st Placeholder:
<Current_Code>open_door(D) :-
    select_door(S),
    prize(P),
    (P \= S, D \= S, D \= P) ->
        0.5::open_door(D) ;
    (P \= S, D \= S, D =:= P) ->
        fail ;
    (P =:= S, D \= S) ->
        0.5::open_door(D).</Current_Code>
<Report>{'592D75CA': {'HASH': '592D75CA', 'Report': "The code defines the open_door/1 predicate with probabilistic and deterministic rules for the Monty Hall problem. However, there are several issues:\n1. The error suggests the predicate '/2' is not found, indicating a syntax or structural problem.\n2. The conditions using '\\=' and '=:=' are correct for inequality/equality checks.\n3. The probabilistic rules (0.5::open_door(D)) are correctly specified for random door opening.\n4. The 'fail' case correctly handles the deterministic empty door scenario.\n5. The structure could be improved by separating the probabilistic and deterministic cases more clearly.", 'Need_regenerate': 'true'}}</Report>
<HASH> Hash tag of code: 592D75CA </HASH>
<LLM> Requirements of Rules: Define open_door/1 Predicate: Random Door Opening Rules Scenario: The remaining two doors are neither selected by the player nor have any prizes. Behavior: The host randomly opens one of the two "empty doors" with a 50% probability. Deterministic Door Opening Rules Scenario: The remaining two doors are neither selected by the player, one of which has a prize and the other does not. Behavior: The host must open the "empty door". </LLM></Langda>
.
win_keep :-
 select_door(A),
 prize(A).
win_switch :-
 member(A, [1,2,3]),
 \+ select_door(A),
 prize(A),
 \+ open_door(A).
query(prize(_)).
query(select_door(_)).
query(win_keep).
query(win_switch).
</Code>
<Final_Answer> The generated completed code should be formatted as follows:
// other contents
```problog
//the completed original code here
```
</Final_Answer>
AI: 


In section <origin_code> and <generated_code> you will be give two codes,
- in <origin_code> there's incomplete code with <langda> blocks.
- in <generated_code> there's completed code of <origin_code>.
your task is to extract and format each code block in <generated_code> that corresponds to the <langda> blocks in <origin_code>
<origin_code>
% Based on Monty Hall problem on https://github.com/friguzzi/cplint
1/3::prize(1) ; 1/3::prize(2) ; 1/3::prize(3).
select_door(1).
member(X,[X|T]).
member(X,[H|T]) :- member(X,T).
<Langda> Information of 1st Placeholder:
<Current_Code>open_door(D) :-
    select_door(S),
    prize(P),
    (P \= S, D \= S, D \= P) ->
        0.5::open_door(D) ;
    (P \= S, D \= S, D =:= P) ->
        fail ;
    (P =:= S, D \= S) ->
        0.5::open_door(D).</Current_Code>
<Report>{'592D75CA': {'HASH': '592D75CA', 'Report': "The code defines the open_door/1 predicate with probabilistic and deterministic rules for the Monty Hall problem. However, there are several issues:\n1. The error suggests the predicate '/2' is not found, indicating a syntax or structural problem.\n2. The conditions using '\\=' and '=:=' are correct for inequality/equality checks.\n3. The probabilistic rules (0.5::open_door(D)) are correctly specified for random door opening.\n4. The 'fail' case correctly handles the deterministic empty door scenario.\n5. The structure could be improved by separating the probabilistic and deterministic cases more clearly.", 'Need_regenerate': 'true'}}</Report>
<HASH> Hash tag of code: 592D75CA </HASH>
<LLM> Requirements of Rules: Define open_door/1 Predicate: Random Door Opening Rules Scenario: The remaining two doors are neither selected by the player nor have any prizes. Behavior: The host randomly opens one of the two "empty doors" with a 50% probability. Deterministic Door Opening Rules Scenario: The remaining two doors are neither selected by the player, one of which has a prize and the other does not. Behavior: The host must open the "empty door". </LLM></Langda>
.
win_keep :-
 select_door(A),
 prize(A).
win_switch :-
 member(A, [1,2,3]),
 \+ select_door(A),
 prize(A),
 \+ open_door(A).
query(prize(_)).
query(select_door(_)).
query(win_keep).
query(win_switch).
</origin_code>
<generated_code>
% Based on Monty Hall problem on https://github.com/friguzzi/cplint
1/3::prize(1) ; 1/3::prize(2) ; 1/3::prize(3).
select_door(1).
member(X,[X|T]).
member(X,[H|T]) :- member(X,T).

open_door(D) :-
    select_door(S),
    prize(P),
    (P \= S, D \= S, D \= P) ->
        0.5::open_door(D) ;
    (P \= S, D \= S, D =:= P) ->
        fail ;
    (P =:= S, D \= S) ->
        0.5::open_door(D).

win_keep :-
    select_door(A),
    prize(A).
win_switch :-
    member(A, [1,2,3]),
    \+ select_door(A),
    prize(A),
    \+ open_door(A).
query(prize(_)).
query(select_door(_)).
query(win_keep).
query(win_switch).
<generated_code>
<Final_Answer> Each code block SHOULD ONLY CONTAINS THE EXACT CONTENT of <langda> blocks, for example:
for the following original code:
<Code>
head(X) :-
<Langda> Information of 1st Placeholder:
<HASH> Hash tag of code: XXXXABCD </HASH>
<LLM> Requirements of Rules:...  </LLM></Langda>
//other contents...
</Code>
if you extracted code contains "head(X) :-", it's wrong, because it's OUTSIDE the <langda> block

For each code block , extract it and format it as follows:
```problog
{"HASH": "XXXX1234","Code": "Completed code snippet 1"}
```
```problog
{"HASH": "XXXX3456","Code": "Completed code snippet 2"}
```
</Final_Answer>