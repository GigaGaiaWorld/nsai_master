System: You are a helpful assistant that helps the user to generate deepproblog code.
Human: You are an expert code evaluator specialized in Problog and DeepProbLog. Your task is to thoroughly analyze the code in <Code> block, evaluate test results in <Result> block, and identify issues that need to be fixed.

<Code>
merge_sort([], []).
merge_sort([X], [X]).
merge_sort(List, Sorted) :-
 
<Langda>
<Code_Block>merge_sort(List, Sorted) :- 
    length(List, Len),
    (Len > 1 ->
        split_list(List, Left, Right),
        merge_sort(Left, SortedLeft),
        merge_sort(Right, SortedRight),
        merge(SortedLeft, SortedRight, Sorted)
    ;
        Sorted = List
    ).</Code_Block>
<HASH> Hash tag of code: 95E704F2 </HASH>
<Requirements>Should contain following rules: 1.Get the length of the current list, Len, to determine whether to continue splitting. 2.Recursive boundary judgment: Only lists with a length greater than 1 need to be sorted, otherwise they are sorted by default. 3.Split the list into two parts, Left and Right, for subsequent recursive processing. </Requirements></Langda>
,
 
<Langda>
<Code_Block>merge_sort(List, Sorted) :- 
    length(List, Len),
    (Len > 1 ->
        split_list(List, Left, Right),
        merge_sort(Left, SortedLeft),
        merge_sort(Right, SortedRight),
        merge(SortedLeft, SortedRight, Sorted)
    ;
        Sorted = List
    ).</Code_Block>
<HASH> Hash tag of code: 26E82D5D </HASH>
<Requirements>Should contain following rules: 1.Recursively call merge sort on the left half, and the result is SortedLeft. 2.Recursively sort the right half, and the result is SortedRight. 3.Merge the two sorted sublists into the final sorted result Sorted. </Requirements></Langda>
.
split_list(List, Left, Right) :-
 length(List, Len),
 Half is Len // 2,
 length(Left, Half),
 append(Left, Right, List).
merge([], List, List).
merge(List, [], List).
merge([H1|T1], [H2|T2], [H1|Merged]) :-
 H1 =< H2,
 merge(T1, [H2|T2], Merged).
merge([H1|T1], [H2|T2], [H2|Merged]) :-
 H1 > H2,
 merge([H1|T1], T2, Merged).
 
append([], L, L).
append([H|T], L2, [H|R]) :-
 append(T, L2, R).
query(merge_sort([3,1,2,5,7,12],X)).
<Result> Here are the testing result of code:
 Error evaluating Problog model:
    toks = self.label_tokens(string, root_tokens)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/zhenzhili/miniforge3/envs/langda/lib/python3.11/site-packages/problog/parser.py", line 1206, in label_tokens
    raise ParseError(string, "Ambiguous token role", t.location)
problog.parser.ParseError: Ambiguous token role at 15:1.</Result>
</Code>

<Evaluation_Instructions>
For each <langda> code block in the original code:
1. Identify the corresponding HASH value
2. Analyze whether it has issues based on the analysis
3. Determine if it needs regeneration
4. Provide detailed reasoning for your decision
5. If there are dependencies between code blocks, identify them

Consider:
- Syntax and logical correctness
- Integration with other code blocks
- Test failures related to this code block
- Implementation of requirements
</Evaluation_Instructions>

<Final_Answer> 
For each code block, format it's report in the following JSON format:
```report
{"HASH": "XXXX1234","Report": "Detailed analysis of issues and recommendations for this specific code block","Need_regenerate": true|false,"Dependencies": ["HASH5678", "HASH9101"] // Only include if this code block depends on others that also need regeneration}
```
```report
{"HASH": "XXXX5678","Report": "Detailed analysis of issues and recommendations for this specific code block","Need_regenerate": true|false,"Dependencies": [] // Empty if no dependencies need regeneration}
```
</Final_Answer>