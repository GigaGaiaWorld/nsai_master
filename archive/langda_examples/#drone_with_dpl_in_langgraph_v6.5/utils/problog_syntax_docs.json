[
    {
    "id": "syntax_probabilistic_facts",
    "title": "Probabilistic Facts",
    "content": "ProbLog introduces probabilistic facts by adding the :: operator. A probabilistic fact is a fact that is true with a certain probability.\n\nFor example, in a coin toss model we can write:\n\n\n0.5::heads.\n\n\nThis indicates that the fact heads is true with probability 0.5 (and false with probability 0.5). Each probabilistic fact represents an independent probabilistic choice. To model multiple coins, use separate facts or a parameterized fact:\n\n\n0.5::heads1.\n0.5::heads2.\n\n% Using a variable to represent any coin toss:\n0.5::heads(C).\n\n",
    "tags": ["syntax", "probabilistic", "fact"],
    "keywords": ["probabilistic fact", "::", "fact"]
    },
    {
    "id": "syntax_annotated_disjunctions",
    "title": "Annotated Disjunctions",
    "content": "ProbLog supports annotated disjunctions to model non-binary probabilistic choices. An annotated disjunction is a set of possible facts of which at most one is true in any world (with given probabilities).\n\nFor example, a six-sided die roll can be modeled as:\n\n\n1/6::die(D, 1); 1/6::die(D, 2); 1/6::die(D, 3);\n1/6::die(D, 4); 1/6::die(D, 5); 1/6::die(D, 6).\n\n\nThis means exactly one of the die(D, N) outcomes will be true (here all six outcomes have equal probability 1/6). There is always an implicit null outcome (none true), which has probability 0 in this case since probabilities sum to 1. Annotated disjunctions can also appear as the head of a rule (with a body condition).",
    "tags": ["syntax", "annotated disjunction"],
    "keywords": ["annotated disjunction", ";", "probabilistic choice"]
    },
    {
    "id": "syntax_probabilistic_clauses",
    "title": "Probabilistic Clauses",
    "content": "ProbLog allows probabilities on the heads of rules (clauses). A probabilistic clause has the form p::Head :- Body., meaning if the Body is true, the Head is true with probability p.\n\nFor example:\n\n\n0.1::burglary.\n0.9::alarm :- burglary.\n\n\nThis means there is a 10% chance of a burglary, and if a burglary happens, it causes an alarm 90% of the time. If the condition in the body is satisfied, the head is still uncertain. Every probabilistic clause can be transformed into an equivalent set of purely probabilistic facts by introducing auxiliary probabilistic facts for the uncertainty (the above example could be rewritten using an intermediate probabilistic fact for alarm_on_burglary).\n\nSimilarly, annotated disjunctions can be used in the head of rules, enabling complex probabilistic processes. For instance, one can define weather dynamics with probabilistic recurrence:\n\n\n0.5::weather(0,sun); 0.5::weather(0,rain).\n0.8::weather(T,sun); 0.2::weather(T,rain) :- T > 0, T1 is T - 1, weather(T1, sun).\n0.4::weather(T,sun); 0.6::weather(T,rain) :- T > 0, T1 is T - 1, weather(T1, rain).\n\n\nThis uses annotated disjunctions in recursive clauses to model weather probabilities over time. (Such programs can be converted into an equivalent form using only probabilistic facts and deterministic rules by introducing additional probabilistic facts as needed.)",
    "tags": ["syntax", "probabilistic", "rule"],
    "keywords": ["probabilistic clause", "::", "rule"]
    },
    {
    "id": "syntax_deterministic_rules",
    "title": "Deterministic Facts and Rules",
    "content": "ProbLog also supports standard (deterministic) Prolog facts and rules without any probability annotation. Such facts and rules are considered certain (probability 1) and behave just like in Prolog.\n\nFor example, a deterministic fact is written as:\n\n\nsunny.\n\n\nand a deterministic rule as:\n\n\nwet :- rain.\n\n\nThese have an implicit probability of 1 (always true if their conditions are met). You can mix deterministic statements with probabilistic ones in a ProbLog program. Essentially, ProbLog extends Prolog syntax by allowing p:: prefixes for probabilistic facts and rules, while retaining normal Prolog syntax for certain knowledge.",
    "tags": ["syntax", "deterministic", "rule"],
    "keywords": ["deterministic", "fact", "rule"]
    },
    {
    "id": "syntax_queries",
    "title": "Queries",
    "content": "A query specifies an atom whose probability of being true should be computed. In ProbLog, queries are added as facts using the query/1 predicate. For example:\n\n\n0.5::heads(c1).\n0.5::heads(c2).\ntwo_heads :- heads(c1), heads(c2).\nquery(two_heads).\n\n\nThis program asks for the probability that both coins come up heads (two_heads). ProbLog can also generate multiple queries programmatically. For instance:\n\n\n0.5::heads(C).\nquery(heads(C)) :- between(1, 4, C).\n\n\nThis adds queries for heads(1), heads(2), heads(3), heads(4) automatically. Non-ground queries (with variables) can be used as long as the program provides enough information to ground all probabilistic parts. For example:\n\n\n0.5::heads(C) :- between(1, 4, C).\nquery(heads(C)).\n\n\nThis effectively queries heads(1) through heads(4) as well.",
    "tags": ["syntax", "query"],
    "keywords": ["query", "query/1", "question"]
    },
    {
    "id": "syntax_evidence",
    "title": "Evidence",
    "content": "Evidence allows us to condition the program on certain observations (events being true or false). We add evidence using the evidence/1 or evidence/2 predicates.\n\nThe fact evidence(Literal) conditions the program such that Literal is assumed true (or false if the literal is negated) when computing probabilities. For example:\n\n\n0.5::heads(c1).\n0.5::heads(c2).\ntwo_heads :- heads(c1), heads(c2).\nevidence(\\+ two_heads).\nquery(heads(c1)).\n\n\nThis program computes the probability that the first coin toss (heads(c1)) is heads given the evidence that not both coins are heads (\\+ two_heads). In other words, we condition on the event that two_heads is false. (The operator \\+ represents negation-as-failure in Prolog.)\n\nAlternatively, evidence can be provided with an explicit truth value using evidence(Atom, true) or evidence(Atom, false) to indicate that a particular atom is observed true or false.",
    "tags": ["syntax", "evidence"],
    "keywords": ["evidence", "conditioning", "observation"]
    },
    {
    "id": "syntax_tabling",
    "title": "Tabling",
    "content": "ProbLog uses tabling (memoization) for all predicates. Tabling automatically caches and reuses results of subgoals, which can significantly improve performance and allow certain recursive definitions that would not terminate in standard Prolog.\n\nFor example, consider the Fibonacci program:\n\n\nfib(1, 1).\nfib(2, 1).\nfib(N, F) :-\n N > 2,\n N1 is N - 1,\n N2 is N - 2,\n fib(N1, F1),\n fib(N2, F2),\n F is F1 + F2.\n\n\nIn normal Prolog, querying fib(N, F) has exponential time complexity because sub-computations are repeated. In ProbLog (with tabling), each unique call (e.g., fib(X, Y) for a given X) is solved once and its result reused, making the computation for Fibonacci linear in N.\n\nTabling also prevents infinite recursion in certain cases. For example, a recursive ancestor definition:\n\n\nparent(ann, bob).\nparent(ann, chris).\nparent(bob, derek).\n\nancestor(X, Y) :- ancestor(X, Z), parent(Z, Y).\nancestor(X, Y) :- parent(X, Y).\n\n\nIn standard Prolog, querying ancestor(ann, X) would loop infinitely, because ancestor(ann, X) recursively calls itself. In ProbLog (tabled evaluation), the system recognizes the repeated call and handles it gracefully, producing the correct descendants of Ann. Similarly, one can write recursive graph reachability (paths in a possibly cyclic graph) without risk of non-termination:\n\n\npath(X, Y) :- edge(X, Y).\npath(X, Y) :- edge(X, Z), path(Z, Y).\n",
    "tags": ["syntax", "tabling", "memoization"],
    "keywords": ["tabling", "memoization", "recursion"]
    },
    {
    "id": "syntax_lfi_mode",
    "title": "Learning from Interpretations (LFI) Mode",
    "content": "When using ProbLog in Learning from Interpretations (LFI) mode (parameter learning), some facts' probabilities are treated as unknown parameters to be learned from data. Instead of a fixed probability, the annotation t(_) is used.\n\nThere are three ways to annotate probabilistic facts in LFI mode:\n- t(_)::fact. indicates the probability of this fact is to be learned (initially a random value).\n- t(p)::fact. (where p is a number) indicates the probability is to be learned, but initialized to p on the first iteration of EM learning.\n- p::fact. (a normal probability) indicates this fact's probability is fixed (not learned).\n\nIn LFI, the model is accompanied by a collection of training examples (interpretations) to learn from. Each example consists of observations provided as evidence statements, and examples are separated by lines containing ---------------- (a delimiter). Within each example, each evidence(Atom, Boolean) specifies whether a certain atom was observed true or false.\n\nFor instance, consider a model:\n\n\nt(_)::heads1.\nt(_)::heads2.\nsomeHeads :- heads1.\nsomeHeads :- heads2.\n\n\nAnd suppose we have examples (observations) as follows:\n\n\nevidence(someHeads,false).\nevidence(heads1,false).\n----------------\nevidence(someHeads,true).\nevidence(heads1,true).\n----------------\nevidence(someHeads,true).\nevidence(heads1,false).\n----------------\n\n\nHere, each block of evidence (separated by ----------------) is one training example. Using LFI, ProbLog can learn the probabilities for heads1 and heads2 that best explain these observations.",
    "tags": ["syntax", "learning", "LFI"],
    "keywords": ["learning", "LFI", "t(_)", "evidence"]
    },
    {
    "id": "syntax_dt_mode",
    "title": "Decision-Theoretic Mode (DTProbLog)",
    "content": "DTProbLog (Decision-Theoretic ProbLog) is an extension of ProbLog for decision-theoretic problems. In a DTProbLog model, the syntax differs in a few key ways:\n- There are no query or evidence statements (the focus is on finding optimal decisions, not computing probabilities of queries).\n- Some facts are marked as decision facts (choices to be made) for which the system will determine the optimal choice.\n- Some atoms have an associated utility value indicating their contribution to an overall utility (reward/cost) that we want to maximize.\n\nA fact can be annotated as a decision in two ways:\n\n\n?::a.\ndecision(a).\n\n\nBoth of the above mark a as a decision fact (with unspecified probability — to be chosen optimally). Utility values are specified using the utility/2 predicate, mapping an atom to a numerical utility, for example:\n\n\nutility(win, 10).\nutility(buy, -1).\n\n\nThese indicate that if win is true it contributes +10 to the total score, and if buy is true it contributes -1 (a cost). In DTProbLog, the goal is typically to maximize expected utility by choosing the best assignments for decision facts.",
    "tags": ["syntax", "decision", "utility"],
    "keywords": ["decision", "utility", "DTProbLog", "optimal"]
    },
    {
    "id": "builtin_control_predicates",
    "title": "Control Predicates",
    "content": "ProbLog supports a subset of Prolog's control constructs (logical connectives and meta-predicates) that do not break the logical (declarative) semantics. It excludes features like cuts and imperative control that have no meaning in a probabilistic setting.\n\nSupported control predicates:\n- Conjunction: P, Q (both P and Q must succeed).\n- Disjunction: P; Q (either P or Q succeeds).\n- true/0 (always succeeds).\n- fail/0 (always fails) and synonym false/0.\n- Negation-as-failure: \\+/1 (or its alias not/1).\n- Meta-call: call/1 (invoke a goal at runtime) and call/N for N up to 9 (for calling predicates with N-1 additional arguments).\n- You can also write a goal directly as a term (which is equivalent to call/1).\n- forall/2 (for all solutions of the first goal, the second goal holds).\n\nSpecial case:\n- once/1 is treated as an alias for call/1 in ProbLog (since backtracking has different implications in a probabilistic context, once simply calls the goal without alternatives).\n\nNot supported control constructs:\n- The cut !/0 is not supported (no hard cut in ProbLog; see the Cut library for an alternative soft cut mechanism).\n- The if-then (->) and if-then-else (*->) constructs are not supported. (You can achieve a similar effect using (Condition, Action) ; (\\+ Condition, Alternative).)\n- repeat/0 is not supported (infinite backtracking loops make no sense probabilistically).\n- Error handling constructs like catch/3 and throw/1 are not supported.\n- Various low-level control and system predicates (abort/0, halt/0, etc.) are not supported.\n- Other Prolog-specific control facilities (like ignore/1, call_with_args/N, etc.) are not available in ProbLog.",
    "tags": ["predicate", "control", "builtin"],
    "keywords": ["if-then","condition","call", "not", "true", "fail"]
    },
    {
    "id": "builtin_arithmetic",
    "title": "Arithmetic Operators",
    "content": "ProbLog supports a wide range of standard arithmetic operations and comparisons, similar to Prolog. Arithmetic is used within the probabilistic logic for things like constraints and computations, but cannot be probabilistic itself (the arithmetic results are deterministic given their inputs).\n\nSupported arithmetic operators and functions include:\n- Basic arithmetic: X, -X (unary negation), X+Y, X-Y, X*Y, X/Y (float division), X//Y (integer division), X mod Y, X rem Y (remainder), X div Y (integer division), X ** Y or X ^ Y (exponentiation).\n- Bitwise operations: X /\\ Y (bitwise AND), X \\/ Y (bitwise OR), X xor Y (bitwise XOR), \\ X (bitwise NOT), X << Y (left shift), X >> Y (right shift).\n- Mathematical functions: exp/1, log/1, log10/1, sqrt/1, sin/1, cos/1, tan/1, asin/1, acos/1, atan/1 (and atan/2), hyperbolic trig functions like sinh/1, cosh/1, tanh/1, and their inverses asinh/1, acosh/1, atanh/1. The gamma-related function lgamma/1 and error functions erf/1, erfc/1 are supported.\n- Type check as arithmetic: integer/1 and float/1 in an arithmetic context (to convert or check numeric types), float_fractional_part/1 and float_integer_part/1.\n- Utility functions: abs/1, ceiling/1, floor/1, round/1, sign/1, truncate/1, max/2, min/2.\n- Arithmetic evaluation and comparison: X is Y (evaluate expression Y and unify with X), and comparison operators X < Y, X =< Y (or <=), X > Y, X >= Y, as well as numeric equality X =:= Y and inequality X =\\= Y (which compare numerical values after evaluation).\n- Additionally: between/3 (generates or checks integers in a range), succ/2 (successor relation for integers), and plus/3 (arithmetic addition relation) are available.\n\nNot supported arithmetic (random and system):\n- Random number generation (random/0, random/1, srandom/1) is not available in the modeling language (probabilistic behavior is handled by the semantics, not by explicit random draws in code).\n- Rational number operations like rational/1 or rationalize/1 are not supported.\n- GCD/bit operations: gcd/2, finding most/least significant bits (msb/1, lsb/1, popcount/1) are not supported.\n- System resource queries like cputime/0, heapused/0, local/0, global/0 (which relate to the Prolog engine's state) are not supported in ProbLog's modeling context.",
    "tags": ["predicate", "arithmetic", "builtin"],
    "keywords": ["is", "+", "-", "between", "mod"]
    },
    {
    "id": "builtin_meta_predicates",
    "title": "Meta-predicates",
    "content": "ProbLog supports the meta-predicate findall/3 for collecting all solutions of a query into a list. It works similarly to Prolog's findall/3, but with one key difference: ProbLog's findall eliminates duplicate solutions (this behavior is akin to all/3 in YAP Prolog). This means if the same answer can be derived in multiple ways, it will appear only once in the collected results.\n\nUsing findall(Term, Goal, List) inside a ProbLog program will bind List to the list of all instances of Term that satisfy Goal (or an empty list if none do). Note that employing findall in a probabilistic context should be done with care, as collecting many solutions can lead to a combinatorial explosion in the probability computations.\n\nOther meta-predicates like bagof/3 or setof/3 are not supported in ProbLog's modeling language. Typically, findall/3 (with duplicate elimination) is sufficient for gathering solutions in ProbLog.",
    "tags": ["predicate", "meta", "builtin"],
    "keywords": ["findall", "bagof", "setof"]
    },
    {
    "id": "builtin_predicates_on_terms",
    "title": "Predicates on Terms",
    "content": "ProbLog supports many of the standard Prolog term inspection predicates (type testing and term manipulation):\n\nSupported predicates on terms include:\n- var/1 (true if argument is an uninstantiated variable).\n- atom/1, float/1, integer/1, number/1 (type checks for atoms, floats, integers, numbers).\n- atomic/1 (true if argument is an atom or number).\n- compound/1 (true if argument is a compound term).\n- nonvar/1 (true if argument is not a variable).\n- callable/1 (true if argument is a callable term).\n- ground/1 (true if term has no variables).\n- db_reference/1 and rational/1 exist but always fail (placeholders for types not used in ProbLog).\n- Term decomposition and construction: arg/3 (access an argument of a compound term), functor/3 (inspect or construct a term's functor and arity), and the univ operator =.. to convert between a term and a list of [functor|arguments].\n- Term equality and inequality: X = Y (unification) and X \\= Y (negated unification).\n- is_list/1 (true if argument is a list).\n- subsumes_term/2 (checks if first term is more general than second).\n\nNot supported (on terms):\n- Occurs-check unification: unify_with_occurs_check/2 (not provided).\n- Term copying and variant checks: copy_term/2, duplicate_term/2, and T1 =@= T2 are not supported.\n- Numbering variables: numbervars/3 is not supported in modeling (though simplified versions exist as ProbLog-specific builtins if needed).\n- acyclic_term/1 is not supported.\n",
    "tags": ["predicate", "term", "builtin"],
    "keywords": ["var", "atom", "compound", "functor"]
    },
    {
    "id": "builtin_predicates_on_atoms",
    "title": "Predicates on Atoms",
    "content": "Standard Prolog predicates for manipulating atoms (such as concatenating atoms, obtaining their length, etc.) are not yet supported in ProbLog's modeling language. (These may be added in a future release.)\n\nIn other words, all built-in predicates specific to atoms (e.g., atom_length/2, atom_concat/3, etc.) are currently unavailable.",
    "tags": ["predicate", "atom", "builtin"],
    "keywords": ["atom_length", "atom_concat", "atoms"]
    },
    {
    "id": "builtin_predicates_on_characters",
    "title": "Predicates on Characters",
    "content": "Predicates dealing with character codes or character classification (for example, checking if a character is a digit or converting between characters and character codes) are not supported in ProbLog. Essentially, no built-in predicates for character manipulation (like those in Prolog's char_code/2 or character classification routines) are available at this time.",
    "tags": ["predicate", "character", "builtin"],
    "keywords": ["char_code", "character"]
    },
    {
    "id": "builtin_comparing_terms",
    "title": "Comparing Terms",
    "content": "ProbLog supports term comparison predicates for checking term order and equality beyond unification:\n\nSupported comparison predicates:\n- compare/3 (total ordering of terms, returns comparison result as <, =, or >).\n- Term identity: X == Y (true if X and Y are exactly the same term) and X \\== Y (true if they are not the same term).\n- Term ordering: X @< Y, X @=< Y, X @> Y, X @>= Y (lexicographic standard order comparisons for terms).\n- sort/2 (sort a list, removing duplicates) and length/2 (get or constrain the length of a list). (Note: In ProbLog, calling length(List, L) with both List and L unbound is not allowed.)\n\nNot supported:\n- keysort/2 and predsort/3 (sorting with custom keys or predicates) are not available.",
    "tags": ["predicate", "compare", "builtin"],
    "keywords": ["compare", "==", "sort", "length"]
    },
    {
    "id": "builtin_handling_undefined",
    "title": "Handling Undefined Procedures",
    "content": "In ProbLog, undefined predicates (calls to predicates that have no definition) can be handled by setting the Prolog flag unknown to fail. By default, any call to an undefined predicate fails.\n\nOne can use unknown(fail) directive to ensure that undefined procedure calls fail silently rather than causing an error. Aside from this, other traditional Prolog behaviors for undefined predicates are not supported.",
    "tags": ["predicate", "undefined", "builtin"],
    "keywords": ["unknown", "undefined predicate", "fail"]
    },
    {
    "id": "builtin_message_handling",
    "title": "Message Handling",
    "content": "Prolog's message handling predicates (for catching and throwing exceptions or printing system messages) are not available in ProbLog's modeling language. Constructs like catch/3, throw/1, and other built-in message or exception handling predicates are not supported in ProbLog.",
    "tags": ["predicate", "exception", "builtin"],
    "keywords": ["catch", "throw", "error"]
    },
    {
    "id": "builtin_problog_specific",
    "title": "ProbLog-Specific Builtins",
    "content": "ProbLog provides some special built-in predicates specific to its environment:\n\n- try_call/N: like call/N (with N arguments) but if the predicate is not defined, it fails without error (useful for optional predicates).\n- subquery(Goal, Probability): computes the probability of Goal as a subquery and unifies it with Probability (allows querying a probability inside the program).\n- subquery(Goal, Probability, EvidenceList): computes the probability of Goal given a list of evidence literals, returning the probability.\n- subquery(Goal, Probability, EvidenceList, Semiring, Evaluator): extended subquery specifying a custom semiring and evaluator by name (advanced usage for different inference strategies).\n- I/O like printing: debugprint/N (print messages to stderr for debugging), write/N (print to stdout), writenl/N (print with newline), nl/0 (newline output).\n- Error raising: error/N which throws a runtime user error with given message.\n- cmd_args/1: retrieve command line arguments passed to ProbLog (when using ProbLog as a script, with -a options).\n- Conversions: atom_number/2 to convert between an atom and a number.\n- Caching control: nocache(Functor, Arity): disable tabling (caching) for the predicate with given name/arity (if needed, to force recalculation every time).\n- Variants of numbervars: numbervars/2 and numbervars/3, and varnumbers/2 for numbering variables (useful in some transformations).\n- Term subsumption checks: subsumes_term/2 and subsumes_chk/2 (similar to subsumes_term, with one likely returning true/false without bindings).\n- Deterministic query: possible/1 which can be used to check if a given atom is possibly true (nonzero probability) under the model.\n- Inspecting the program: clause/2 and clause/3 to retrieve clauses from the program (similar to Prolog's clause/2,3 for dynamic code inspection of the ProbLog program).\n- Working with scopes (see Scope library): create_scope/2 to create a new named sub-theory, subquery_in_scope(Scope, Goal, Probability, ...) variants to query probabilities within a specific scope, and call_in_scope/N to call goals within a scope.\n- State management: set_state/1, reset_state/0, check_state/1, print_state/0 for advanced users to manipulate the solver state or sequences.\n- Sequence generation: seq/1 which unifies its argument with a new unique sequential number each time it is called (useful for generating unique IDs).",
    "tags": ["predicate", "problog", "builtin"],
    "keywords": ["subquery", "try_call", "debugprint", "possible"]
    },
    {
    "id": "library_lists",
    "title": "Lists Library (library(lists))",
    "content": "The Lists library (library(lists)) provides list-processing predicates. It implements all predicates from SWI-Prolog's standard lists library, including:\nmemberchk/2, member/2, append/3 (and append/2), prefix/2, select/3 (and selectchk/3 variants, and 4-argument versions), nextto/3, delete/3, nth0/3, nth1/3 (and their 4-argument forms), last/2, proper_length/2, same_length/2, reverse/2, permutation/2, flatten/2, max_member/2, min_member/2, sum_list/2, max_list/2, min_list/2, numlist/3, is_set/1, list_to_set/2, intersection/3, union/3, subset/2, subtract/3.\n\nIn addition to these standard predicates, ProbLog's lists library provides some extra predicates useful in probabilistic modeling:\n- select_uniform(+ID, +Values, ?Value, ?Rest): Selects one element uniformly at random from Values, unifying Value with the chosen element and Rest with the remaining list. The ID can be used to tie multiple selections together (so that the same random choice is reused in multiple places if the ID matches).\n- select_weighted(+ID, +Weights, +Values, ?Value, ?Rest): Selects one element from Values with probability proportional to the corresponding weight in Weights. Works similarly to select_uniform but uses a list of weights for a weighted random choice.\n- groupby(?List, ?Groups): Partitions a list of terms into groups of identical terms (unifying Groups with a list of groups).\n- sub_list(?List, ?Before, ?Length, ?After, ?SubList): Extracts a sub-list of length Length from List such that SubList appears with Before elements before it and After elements after it in the original list.\n- enum_groups(+Groups, +Values, -Group, -GroupedValues) (and its variant enum_groups(+GroupedValues, -Group, -GroupedValues)): Enumerate group names and their associated values from a grouping structure.\n- unzip(ListAB, ListA, ListB): Splits a list of pair terms into two lists, one with all first components and one with all second components.\n- zip(ListA, ListB, ListAB): The inverse of unzip; pairs corresponding elements from ListA and ListB into a list of pair terms ListAB.\n- make_list(+Len, +Elem, ?List): Creates a list of length Len filled with copies of Elem (or checks that a given List has that form).",
    "tags": ["library", "lists"],
    "keywords": ["member", "append", "reverse", "flatten"]
    },
    {
    "id": "library_apply",
    "title": "Apply Library (library(apply))",
    "content": "The Apply library (library(apply)) provides predicates for applying operations over lists and filtering. It implements all predicates from SWI-Prolog's apply library, such as:\ninclude/3 (filtering a list with a predicate), exclude/3 (filter out elements satisfying a predicate), partition/4 and partition/5 (partition a list based on a condition into two or three lists), maplist/2..5 (apply a predicate or function element-wise to one or more lists), convlist/3 (like maplist but collects only non-fail results), and fold predicates foldl/4..7 and scan predicates scanl/4..7 for accumulating results across a list.\n\nThese higher-order predicates allow concise expression of operations on lists by providing either an existing predicate or a lambda-like predicate to be applied to list elements.",
    "tags": ["library", "apply"],
    "keywords": ["include", "exclude", "maplist", "foldl"]
    },
    {
    "id": "library_cut",
    "title": "Cut Library (library(cut))",
    "content": "ProbLog does not support the standard Prolog cut (!) in its syntax, but it provides a Cut library (library(cut)) to achieve a similar effect in a controlled way. The cut library implements a soft cut mechanism that allows exactly one rule in a set to succeed (the first that succeeds in a given order), simulating an ordered rule set.\n\nTo use it, first define an indexed set of clauses (by adding an index as the first argument of each clause). For example:\n\n\nr(1, a, b).\nr(2, a, c).\nr(3, b, c).\n\n\nThen, use the cut/1 predicate around a call to that predicate (omitting the index argument) to enforce that only the first matching clause succeeds:\n\n\ncut(r(A, B)).\n\n\nThis will evaluate r clauses in order of their index (note: the numeric index, not the textual order in the file) and succeed with the first applicable result, ignoring any alternative solutions from later clauses.\n\nExample: If we query some uses of cut(r(...)):\n\ncut(r(A, B)) % might yield A = a, B = b (using the first clause)\ncut(r(a, X)) % yields X = b (only the r(1, a, b) clause fires)\ncut(r(X, c)) % yields X = a (only the first clause with B=c, which is r(2, a, c), fires)\ncut(r(b, X)) % yields X = c (the first clause that matches is r(3, b, c))\n\nAdditionally, the library provides cut/2 which, when used as cut(Pred, Index), unifies Index with the index of the clause that succeeded for Pred. This can be used to retrieve which rule was applied.",
    "tags": ["library", "cut"],
    "keywords": ["cut", "!", "soft cut"]
    },
    {
    "id": "library_assert",
    "title": "Assert Library (library(assert))",
    "content": "The Assert library (library(assert)) enables dynamic modification of the probabilistic knowledge base by adding or removing facts at runtime. It provides:\n\n- assertz/1: Add a fact or rule to the program (assert it at the end of the database).\n- retract/1: Remove a fact or rule that matches the given head (removes the first occurrence by default).\n- retractall/1: Remove all facts or rules matching the given head/pattern.\n\nUsing these predicates, one can dynamically change the model (though care should be taken as ProbLog's inference assumes a static program; dynamic changes primarily make sense in an interactive or iterative context).",
    "tags": ["library", "assert", "dynamic"],
    "keywords": ["assertz", "retract", "dynamic"]
    },
    {
    "id": "library_record",
    "title": "Record Library (library(record))",
    "content": "The Record library (library(record)) provides access to a non-backtrackable record database. It allows storing and retrieving terms in a way that persists across backtracking (like a global store):\n\n- current_key/1: Enumerate or check existing record keys.\n- recorda(Key, Term) and recordz(Key, Term): Record a term under a given key (at the beginning or end of the entries for that key, respectively). Variants recorda/3 and recordz/3 also give a reference to the recorded entry.\n- recorded(Key, Term): Retrieve a term recorded under a key (with a variant recorded/3 that also gives a reference).\n- erase(Ref): Remove a recorded term by reference (the reference obtained from recorda/3 or recordz/3).\n- instance(Ref, Term): Retrieve a term by reference (unifying Term with the term stored at Ref).",
    "tags": ["library", "record", "storage"],
    "keywords": ["recorda", "recordz", "recorded", "erase"]
    },
    {
    "id": "library_aggregate",
    "title": "Aggregate Library (library(aggregate))",
    "content": "The Aggregate library (library(aggregate)) introduces an aggregation operator for ProbLog, inspired by the LDL++ style of aggregation. It allows one to define rules that aggregate sets of solutions into a single result (like summing or averaging values).\n\nTo use it, first include the library with:\n\n:- use_module(library(aggregate)).\n\n\nAn aggregating clause has the form:\n\n\nFUNCTOR(*GroupArgs, AggFunc<AggVar>) :- BODY.\n\n\nWhere:\n- FUNCTOR is the predicate name for the aggregate result.\n- GroupArgs is an optional list of arguments to group by (i.e., the aggregate is computed separately for each distinct combination of these arguments).\n- AggFunc is an aggregation function (a binary predicate that takes a list of values and returns some aggregated value).\n- AggVar is the variable in the BODY whose values will be collected and aggregated.\n- BODY is the normal rule body whose solutions provide values to aggregate.\n\nThe library provides built-in aggregation functions: sum, avg, min, max (which compute sum, average, minimum, and maximum of a list of numbers). You can also use any user-defined predicate of arity 2 as an aggregation function (for example, the standard proper_length/2 from the lists library can serve as a count aggregator by returning the length of the list).\n\nExample: Suppose we have people with salaries and departments:\n\n\n:- use_module(library(aggregate)).\n\nperson(a). person(b). person(c). person(d). person(e).\nsalary(a, 1000). salary(b, 1200). salary(c, 800). salary(d, 1100). salary(e, 1400).\ndept(a, dept_a). dept(b, dept_a). dept(c, dept_b). dept(d, dept_b). dept(e, dept_a).\n\n% Average salary per department:\ndept_salary(Dept, avg<Salary>) :- person(X), salary(X, Salary), dept(X, Dept).\nquery(dept_salary(Dept, Salary)).\n% Example query results:\n% dept_salary(dept_a, 1200.0) 1\n% dept_salary(dept_b, 950.0) 1\n\n% Max salary per department:\ndept_max_salary(Dept, max<Salary>) :- person(X), salary(X, Salary), dept(X, Dept).\nquery(dept_max_salary(Dept, Salary)).\n% dept_max_salary(dept_a, 1400) 1\n% dept_max_salary(dept_b, 1100) 1\n\n% Average salary company-wide (no grouping):\nall_salary(avg<Salary>) :- person(X), salary(X, Salary), dept(X, Dept).\nquery(all_salary(Salary)).\n% all_salary(1100.0) 1\n\n\nAs shown, you use the syntax AggFunc<Variable> in the head to indicate aggregation. These aggregates also work with probabilistic data (the query results will include probabilities for each aggregate outcome).",
    "tags": ["library", "aggregate"],
    "keywords": ["aggregate", "sum", "avg", "min", "max"]
    },
    {
    "id": "library_collect",
    "title": "Collect Library (library(collect))",
    "content": "The Collect library (library(collect)) introduces a convenient operator => for aggregation in ProbLog, generalizing the concept of collecting all solutions (all/3). It allows writing inline aggregation of query results with grouping.\n\nThe general syntax is:\n\n\n( CodeBlock ) => GroupBy / AggFunc(Arg1, Arg2, ..., ArgK)\n\n\nWhere:\n- CodeBlock is a sequence of goals (like a mini query) that will produce solutions.\n- GroupBy is an optional expression denoting how to group results (often one or more variables from the CodeBlock, or an expression on them). If provided, aggregation is done separately for each distinct value of GroupBy.\n- AggFunc(Arg1,...,ArgK) is an aggregation function with its arguments, where one of the arguments will hold the aggregated result.\n\nTo use this operator, you define a corresponding predicate collect_AggFunc that specifies how to perform the aggregation, typically by delegating to the aggregate/5 predicate from the Aggregate library.\n\nFor example, if we want to compute an average over solutions, we could define:\n\n\ncollect_avg(CodeBlock, GroupBy, AggVar, AggRes) :-\n aggregate(avg, AggVar, GroupBy, CodeBlock, (GroupBy, AggRes)).\n\n\nThen we can use the => operator in a rule. Suppose we have facts:\n\ncell(Row, Col, Value). cell_type(Row, Col, Type).\n\nIf we want to compute the average of all Value for each column where the cell type is 'int', we can write:\n\n\ncolumn_average(Col, Avg) :- (\n cell(R, Col, Value),\n cell_type(R, Col, 'int')\n) => Col / avg(Value, Avg).\n\n\nHere => Col / avg(Value, Avg) means: group results by Col and aggregate the Value field using the avg function, yielding Avg. We assume collect_avg is defined as above to handle avg.\n\nThe collect library thus provides a flexible way to embed aggregation directly in the model logic by defining custom collect_Function predicates for any aggregation function you need.",
    "tags": ["library", "collect", "aggregation"],
    "keywords": ["collect", "=>", "all/3"]
    },
    {
    "id": "library_db",
    "title": "DB Library (library(db))",
    "content": "The DB library (library(db)) allows integration of external data (from databases or CSV files) into a ProbLog model. It provides predicates to load data:\n\n- sqlite_load(Filename): Given an SQLite database file, this predicate creates a set of virtual predicates corresponding to each table in the database. You can then query those predicates as if they were facts in the ProbLog program (the data is fetched from the database on the fly).\n- sqlite_csv(Filename, Predicate): Given a CSV file, this creates a new predicate (with name given by Predicate) whose facts are the rows of the CSV file. Each row becomes a fact of that predicate with arguments corresponding to columns.\n\nThis is useful for probabilistic reasoning over large data sets stored externally. See the ProbLog documentation or tutorials for examples on how to use these predicates.",
    "tags": ["library", "database"],
    "keywords": ["sqlite_load", "sqlite_csv", "database", "CSV"]
    },
    {
    "id": "library_scope",
    "title": "Scope Library (library(scope))",
    "content": "The Scope library (library(scope)) provides support for multiple sub-models or scopes within a single ProbLog program. It introduces a scope operator :/2 which allows qualifying a fact or query with a scope identifier.\n\nThe syntax ScopeID:Predicate denotes a predicate that belongs to a specific scope. For example:\n\n\nscope(1):knowledge(1).\n\n\ndefines a fact knowledge(1) in scope 1. You can query within a scope or combine scopes:\n\n\nscope(1):a.\nscope(2):b.\nscope(3):X :- scope(1):X; scope(2):X.\nquery(scope(3):_).\n\nThis program will yield results for scope(3):_ combining facts from scope 1 and 2. The results might look like:\n\nscope(3):a: 1\nscope(3):b: 1\n\nHere, scope(3):X :- scope(1):X; scope(2):X defines scope 3 as effectively the union of scopes 1 and 2.\n\nThe scope library provides additional behaviors:\n- Conjunction reasoning in a scope: For example, if scope 1 has a. and b., then querying scope(1):(a,b) will succeed (and ProbLog will give it probability 1, since both a and b are true in that scope).\n\nscope(1):a.\nscope(1):b.\nquery(scope(1):(a,b)).\n\nResult:\n\nscope(1):(a,b): 1\n\n- Temporary unions via list: You can query a list of scopes combined. For example, using scopes from above:\n\nquery([scope(1), scope(2)]:b).\n\nThis asks whether b is true in the union of scope 1 and 2. In the example, it would succeed (since scope 2 has b) with result:\n\n[scope(1), scope(2)]:b: 1\n\n- Global facts in all scopes: Any fact not explicitly in a scope (i.e., defined at the top level) is considered to be present in all scopes. For instance, if we have a. as a top-level fact, then any scope query like scope(1):a will treat a as true in that scope.\n\nUsing scopes, one can manage multiple probabilistic sub-theories within one program, and combine them flexibly. The scope library extends this functionality, but details beyond basic usage often involve advanced techniques (see the documentation for more information).",
    "tags": ["library", "scope"],
    "keywords": ["scope", ":", "multi-model"]
    },
    {
    "id": "library_string",
    "title": "String Library (library(string))",
    "content": "The String library (library(string)) provides predicates for basic string manipulation. This includes typical operations such as concatenating strings, splitting strings, converting between strings and character codes, etc., analogous to those available in Prolog's library for strings. (Refer to the ProbLog documentation for the specific predicates available, as this library is primarily for convenience when dealing with textual data inside ProbLog models.)",
    "tags": ["library", "string"],
    "keywords": ["string", "text", "concatenation"]
    },
    {
    "id": "library_nlp4plp",
    "title": "NLP4PLP Library (library(nlp4plp))",
    "content": "The NLP4PLP library (library(nlp4plp)) is a specialized library for representing and solving probabilistic questions posed in natural language (NLP for Probabilistic Logic Programming). It provides an interface and predicates to model certain natural language probability problems within ProbLog. For more information on usage and capabilities of this library, refer to the dedicated NLP4PLP documentation or webpage, as it involves integration of NLP techniques with probabilistic logic.",
    "tags": ["library", "NLP", "plp"],
    "keywords": ["NLP4PLP", "natural language", "probability"]
    },
    {
    "id": "example_smoking_influence",
    "title": "Example: Smoking Influence Network",
    "content": "This example model illustrates a social network influence scenario in ProbLog. People can experience stress or influence each other to smoke, and smoking can cause asthma. The model combines probabilistic facts and rules:\n\n\n0.3::stress(X) :- person(X).\n0.2::influences(X,Y) :- person(X), person(Y).\n\nsmokes(X) :- stress(X).\nsmokes(X) :- friend(X,Y), influences(Y,X), smokes(Y).\n\n0.4::asthma(X) :- smokes(X).\n\nperson(angelika).\nperson(joris).\nperson(jonas).\nperson(dimitar).\n\nfriend(joris, jonas).\nfriend(joris, angelika).\nfriend(joris, dimitar).\nfriend(angelika, jonas).\n\n\nIn this model, each person has a 30% chance of being stressed, and each friendship provides a 20% chance of influence for smoking. A person smokes if they are stressed or if a friend influences them and that friend smokes (recursive peer influence). Additionally, if a person smokes, there is a 40% chance they have asthma. The deterministic person/1 and friend/2 facts define the social network structure.",
    "tags": ["example", "probabilistic model"],
    "keywords": ["smokes", "influences", "asthma", "network"]
    },
    {
    "id": "example_burglary_alarm",
    "title": "Example: Burglary Alarm with Evidence",
    "content": "This example is analogous to a simple alarm network from Bayesian networks. A burglary or an earthquake can set off an alarm, and two people (Mary and John) may call when they hear the alarm. We use evidence to infer the cause of the alarm.\n\n\n0.2::burglary.\n0.1::earthquake.\n\n0.9::alarm :- burglary.\n0.8::alarm :- earthquake.\n\n0.7::maryCalls :- alarm.\n0.9::johnCalls :- alarm.\n\n% Evidence: Mary has called\n evidence(maryCalls).\n\n% Query: what is the probability of a burglary given Mary called?\n query(burglary).\n\n\nIn this program, burglary and earthquake are independent probabilistic causes of an alarm. The alarm will sound with 90% probability if there's a burglary, and 80% if there's an earthquake. Mary calls with 70% probability when the alarm rings, and John calls with 90%. We then condition on the evidence that Mary has called (evidence(maryCalls)) and query the probability of a burglary. This example demonstrates how evidence updates the probability of causes.",
    "tags": ["example", "evidence", "alarm"],
    "keywords": ["alarm", "burglary", "evidence", "query"]
    }
    ]