{
  "file_name": "pl___aircr_precise",
  "run_index": 5,
  "Validity_form": true,
  "Validity_result": true,
  "running_time": "87.13s",
  "process_time": 87.13383603096008,
  "final_result": "% Aircraft Flap Controller\n% This example is inspired by one in Filieri et al, Reliability Analysis in Symbolic Pathfinder, ICSE 2013\n% the range of the flap\nlegal_flap_position(FP) :- between(0,10,FP).\n% the strength of the actuators\nactuator_strength(a,2).\nactuator_strength(b,1).\n% random prior on which actuator to use\n0.5::use_actuator(T,a); 0.5::use_actuator(T,b).\n% wind strength model\n0.7::wind(weak); 0.3::wind(strong).\n0.25::wind_effect(T,-1); 0.5::wind_effect(T,0); 0.25::wind_effect(T,1) :- wind(weak).\n0.2::wind_effect(T,-3); 0.3::wind_effect(T,-2); 0.3::wind_effect(T,2); 0.2::wind_effect(T,3) :- wind(strong).\n% the flap is moved to an attempted position if that is legal\nflap_position(Time,Pos) :-\n Time > 0,\n attempted_flap_position(Time,Pos),\n legal_flap_position(Pos).\n% an overrun exception occurs else\noverrun_exception(Time) :-\n attempted_flap_position(Time,Pos),\n \\+ legal_flap_position(Pos).\n% did we reach the goal?\ngoal_reached(Time) :-\n goal(G),\n flap_position(Time,G).\n% if the previous position was not the goal, attempt a new position\n% the position depends on the chosen actuator and the current wind\nattempted_flap_position(Time,Pos) :-\n Time > 0,\n Prev is Time-1,\n \n flap_position(Prev,Old), \\+ goal_reached(Prev), goal(GP), use_actuator(Time,A), actuator_strength(A,AS), AE is sign(GP - Old) * AS, wind_effect(Time,WE), Pos is Old + AE + WE.\n% we want to go from 6 to 4, i.e., move two steps left\nflap_position(0,6).\ngoal(4).\n% restrict attention to first five steps\nat(5).\nquery(goal_reached(T)) :- at(S),between(1,S,T).\nquery(overrun_exception(T)) :- at(S),between(1,S,T).",
  "final_report": "The generated code is functionally equivalent to the original code. The main difference is in the formatting and the rearrangement of conditions in the 'attempted_flap_position' rule, which does not affect the logic or outcome. The generated code maintains all the original functionality and constraints, producing identical results when executed."
}