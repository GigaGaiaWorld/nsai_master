{
  "file_name": "pl___robot_precise",
  "run_index": 1,
  "Validity_form": true,
  "Validity_result": true,
  "running_time": "67.68s",
  "process_time": 67.6818687915802,
  "final_result": "% source: David Poole. Abducing through negation as failure: stable models within the independent choice logic. JLP 2000.\ncarrying(key,s(T)) :-\n do(pickup(key),T),\n at(robot,Pos,T),\n at(key,Pos,T),\n pickup_succeeds(T).\ncarrying(key,s(T)) :-\n carrying(key,T),\n \\+ do(putdown(key),T),\n \\+ do(pickup(key),T),\n \\+ drops(key,T).\n \n0.7::pickup_succeeds(T); 0.3::pickup_fails(T).\n \ndrops(key,T) :-\n slippery(key,T),\n drop_slippery_key(T).\ndrops(key,T) :-\n \\+ slippery(key,T),\n fumbles_key(T).\n \n0.6::drop_slippery_key(T); 0.4::holds_slippery_key(T).\n0.2::fumbles_key(T); 0.8::retains_key(T).\n \nslippery(key,s(T)) :-\n slippery(key,T),\n stays_slippery(T).\nslippery(key,0) :-\n initially_slippery(key).\n \n0.75::stays_slippery(T); 0.25::stops_being_slippery(T).\n0.5::initially_slippery(key); 0.5::initially_unslippery(key).\n \nat(robot,Pos,s(T)) :-\n    do(goto(Pos),T),\n    goto_succeeds(T).\nat(robot,Pos,s(T)) :-\n    at(robot,Pos,T),\n    do(goto(_),T),\n    goto_fails(T).\nat(robot,Pos,s(T)) :-\n    at(robot,Pos,T),\n    \\+ goto_action(T).\nat(key,Pos,T) :-\n    carrying(key,T),\n    at(robot,Pos,T).\nat(key,Pos,s(T)) :-\n    \\+ carrying(key,s(T)),\n    at(key,Pos,T).\n0.9::goto_succeeds(T); 0.1::goto_fails(T).\n \ngoto_action(T) :-\n do(goto(Pos),T).\n \ndo(goto(loc1),0).\ndo(pickup(key),s(0)).\ndo(goto(loc2),s(0)).\nat(key,loc1,0).\nat(robot,loc0,0).\n \nquery(carrying(key,s(s(s(0))))).\nquery(at(_,_,s(s(s(0))))).",
  "final_report": "The generated code is largely consistent with the original code in terms of logic and functionality. The main difference lies in the formatting and the slight reordering of clauses in the 'at(robot,Pos,s(T))' predicate, which does not affect the semantic meaning or the execution results. Both codes produce identical output probabilities for all queried predicates, indicating that the generated code correctly implements the intended probabilistic logic program."
}