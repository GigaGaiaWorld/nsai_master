% Cryptoaddition:
% Find the unique answer to:
% Define available digits
digit(0).
 digit(1).
 digit(2).
 digit(3).
 digit(4).
digit(5).
 digit(6).
 digit(7).
 digit(8).
 digit(9).
% The first digit of a multi-digit number cannot be 0
leftdigit(D) :- digit(D), D =\= 0.
% All elements are different
all_different([]).
all_different([H|T]) :- \+ member(H, T), all_different(T).
member(X, [X|_]).
member(X, [_|T]) :- member(X, T).
% Simulate a column addition: Cin is the input carry, Cout is the output carry
sumdigit(Cin, A, B, Sum, Cout) :-
 X is Cin + A + B,
 ( X < 10, Sum = X, Cout = 0
 ; 
 X >= 10, Sum is X - 10, Cout = 1 ).
% Main predicate: AB + BCD = CDE
query_sum([A,B,C,D,E]) :-
 
 leftdigit(A), leftdigit(B), leftdigit(C), digit(D), digit(E), all_different([A,B,C,D,E]), sumdigit(0, B, D, E, C1), sumdigit(C1, A, C, D, C2), sumdigit(C2, 0, B, C, C3), C3 = 0.
% Initiate query example:
query(query_sum([A,B,C,D,E])).

/* Result Report:
Validity_form: True
Validity_result: True
Report: The generated code is mostly correct and consistent with the original code. It maintains the same logic for digit definitions, leftdigit constraints, all_different checks, and sumdigit calculations. The main predicate query_sum is also correctly implemented, though the constraints are written in a single line which doesn't affect functionality. The only minor change is the introduction of C3 in the generated code, which is immediately constrained to 0, effectively replicating the original behavior of having no carry. The running results of both codes are identical, confirming their functional equivalence.
*/